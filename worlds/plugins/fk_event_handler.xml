<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
    name="FK_Event_Handler"
    author="Areia"
    id="35365d0a213358e5f89e11cd"
    language="Lua"
    purpose="Track and broadcast events"
    save_state="n"
    date_written="2022-03-23 17:00:00"
    requires="5.06"
    version="0.00"
>
<description trim="y">
<![CDATA[
]]>
</description>

</plugin>

<include name="constants.lua"/>



<aliases>
</aliases>


<triggers>
</triggers>


<script>
<![CDATA[
require("commas")
require("serialize")
require("tprint")
require("var")
require("wait")
local const = require("fk_const")


--------------------------------------------------
-- EventHandler
-------------------------------------------------


EventHandler = {}
EventHandler.cache = {}


function EventHandler.event(eventType, path, data)
    local errorMsg = "Arg%d to EventHandler.event must be %s. Got %s."
    assert(
        type(eventType) == "number",
        errorMsg:format(1, "number", type(eventType))
    )
    assert(
        type(path) == "string",
        errorMsg:format(2, "string", type(path))
    )
    assert(
        type(data) == "table",
        errorMsg:format(3, "table", type(data))
    )

    -- Find where to store info, and build path to that location if
    -- necessary as we go.
    local node = EventHandler.cache
    local prevNode = nil
    local prevLevel = ""
    for level in path:gmatch("%a+") do
        node[level] = node[level] or {}
        prevNode = node
        prevLevel = level
        node = node[level]
    end
    prevNode[prevLevel] = data

    BroadcastPlugin(eventType, path)
end


function EventHandler.get(path)
    local errorMsg = "Arg1 to EventHandler.get must be string. Got %s."
    assert(
        type(path) == "string",
        errorMsg:format(type(path))
    )

    local node = EventHandler.cache
    for level in path:gmatch("%a+") do
        if (not node[level]) then
            return nil
        end
        node = node[level]
    end
    return node
end


function EventHandler.get_as_string(path)
    return serialize.save_simple(EventHandler.get(path) or "")
end
]]>
</script>



<triggers>
    <trigger
     match="^(?<speaker>.+) (?<verb>ask|exclaim|say)s?,? '(?<message>.+)'$"
     enabled="y"
     script="Communication.say"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     match="^(?<speaker>.+) (?<verb>ask|exclaim|say)s? to (?<receiver>.+),? '(?<message>.+)'$"
     enabled="y"
     script="Communication.say"
     regexp="y"
     sequence="100"
    >
    </trigger>

    <trigger
     match="^(?<speaker>.+) tells? (?<receiver>.+),? '(?<message>.+)'$"
     enabled="y"
     script="Communication.tell"
     regexp="y"
     sequence="100"
    >
    </trigger>

    <trigger
     match="^(?<speaker>.+) yells?,? '(?<message>.+)'$"
     enabled="y"
     script="Communication.yell"
     regexp="y"
     sequence="100"
    >
    </trigger>
</triggers>


<script>
<![CDATA[
--------------------------------------------------
-- Communication
--------------------------------------------------


Communication = {}


function Communication.event(data)
    local path = "comm." .. data.channel
    EventHandler.event(const.EVENT_TYPE.COMMUNICATION, path, data)
end


function Communication.say(trigger, line, wc)
    Communication.event{
        channel = "say",
        speaker = wc.speaker,
        receiver = wc.receiver or "",
        message = wc.message,
        line = line,
    }
end


function Communication.tell(trigger, line, wc)
    if not (wc.speaker == "You" or wc.receiver == "you") then
        -- Probably a smoted message, not an actual tell to player.
        return
    end

    Communication.event{
        channel = "tell",
        speaker = wc.speaker,
        receiver = wc.receiver,
        message = wc.message,
        line = line,
    }
end


function Communication.yell(trigger, line, wc)
    Communication.event{
        channel = "yell",
        speaker = wc.speaker,
        message = wc.message,
        line = line,
    }
end
]]>
</script>


</muclient>

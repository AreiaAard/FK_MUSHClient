<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
    name="FK_Event_Handler"
    author="Areia"
    id="35365d0a213358e5f89e11cd"
    language="Lua"
    purpose="Track and broadcast events"
    save_state="n"
    date_written="2022-03-23 17:00:00"
    requires="5.06"
    version="0.00"
>
<description trim="y">
<![CDATA[
]]>
</description>

</plugin>

<include name="constants.lua"/>



<aliases>
</aliases>


<triggers>
</triggers>


<script>
<![CDATA[
require("commas")
require("json")
require("tprint")
require("var")
require("wait")
local const = require("fk_const")


--------------------------------------------------
-- EventHandler
-------------------------------------------------


EventHandler = {}
EventHandler.cache = {}


function EventHandler.event(eventType, path, data)
    local errorMsg = "Arg%d to EventHandler.event must be %s. Got %s."
    assert(
        type(eventType) == "number",
        errorMsg:format(1, "number", type(eventType))
    )
    assert(
        type(path) == "string",
        errorMsg:format(2, "string", type(path))
    )
    assert(
        type(data) == "table",
        errorMsg:format(3, "table", type(data))
    )

    -- Find where to store info, and build path to that location if
    -- necessary as we go.
    local node = EventHandler.cache
    local prevNode = nil
    local prevLevel = ""
    for level in path:gmatch("%a+") do
        node[level] = node[level] or {}
        prevNode = node
        prevLevel = level
        node = node[level]
    end
    prevNode[prevLevel] = data

    BroadcastPlugin(eventType, path)
end


function EventHandler.get(path)
    local errorMsg = "Arg1 to EventHandler.get must be string. Got %s."
    assert(
        type(path) == "string",
        errorMsg:format(type(path))
    )

    local node = EventHandler.cache
    for level in path:gmatch("%a+") do
        if (not node[level]) then
            return nil
        end
        node = node[level]
    end
    return node
end


function EventHandler.get_as_string(path)
    return json.encode(EventHandler.get(path) or "")
end
]]>
</script>



<triggers>
    <trigger
     match="^Please select the character you wish to play \[[0-9 -]+, default:\d+\]: You have chosen to play (?<character>\w+)\.$"
     enabled="y"
     script="Char.login"
     regexp="y"
     sequence="100"
    >
    </trigger>

    <trigger
     match="^A strange voice says, 'We await your return, (?<character>\w+)\.\.\.'$"
     enabled="y"
     script="Char.logout"
     regexp="y"
     sequence="101"
    >
    </trigger>
</triggers>


<script>
<![CDATA[
--------------------------------------------------
-- Char
--------------------------------------------------


Char = {}


function Char.login(trigger, line, wc)
    local path = "char.login"
    local data = {name=wc.character, line=line}
    EventHandler.event(const.EVENT_TYPE.LOGIN, path, data)
end


function Char.logout(trigger, line, wc)
    local path = "char.logout"
    local data = {name=wc.character, line=line}
    EventHandler.event(const.EVENT_TYPE.LOGIN, path, data)
end
]]>
</script>



<triggers>
    <trigger
     match="^(?<speaker>.+) (?<verb>ask|exclaim|say)s?,? '(?<message>.+)'$"
     enabled="y"
     script="Communication.say"
     regexp="y"
     keep_evaluating="y"
     sequence="100"
    >
    </trigger>
    <trigger
     match="^(?<speaker>.+) (?<verb>exclaim|say)s? to (?<receiver>.+),? '(?<message>.+)'$"
     enabled="y"
     script="Communication.say"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     match="^(?<speaker>.+) (?<verb>ask)s? (?<receiver>.+),? '(?<message>.+)'$"
     enabled="y"
     script="Communication.say"
     regexp="y"
     sequence="100"
    >
    </trigger>

    <trigger
     match="^(?<speaker>.+) tells? (?<receiver>.+),? '(?<message>.+)'$"
     enabled="y"
     script="Communication.tell"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     match="^(?<speaker>.+) repl(?:y|ies) to (?<receiver>.+),? '(?<message>.+)'$"
     enabled="y"
     script="Communication.tell"
     regexp="y"
     sequence="100"
    >
    </trigger>

    <trigger
     match="^(?<speaker>.+) yells?,? '(?<message>.+)'$"
     enabled="y"
     script="Communication.yell"
     regexp="y"
     sequence="100"
    >
    </trigger>

    <trigger
     match="^(?<speaker>.+) says?, OOC '(?<message>.+)'$"
     enabled="y"
     script="Communication.osay"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     match="^(?<speaker>.+) tells? (?<receiver>.+), OOC '(?<message>.+)'$"
     enabled="y"
     script="Communication.otell"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     match="^(?<speaker>.+) repl(?:y|ies) to (?<receiver>.+), OOC '(?<message>.+)'$"
     enabled="y"
     script="Communication.otell"
     regexp="y"
     sequence="100"
    >
    </trigger>
</triggers>


<script>
<![CDATA[
--------------------------------------------------
-- Communication
--------------------------------------------------


Communication = {}


function Communication.event(data)
    local path = "comm." .. data.channel
    EventHandler.event(const.EVENT_TYPE.COMMUNICATION, path, data)
end


function Communication.say(trigger, line, wc)
    Communication.event{
        channel = "say",
        speaker = wc.speaker,
        receiver = wc.receiver or "",
        message = wc.message,
        line = line,
    }
end


function Communication.tell(trigger, line, wc)
    if not (wc.speaker == "You" or wc.receiver == "you") then
        -- Probably a smoted message, not an actual tell to player.
        return
    end

    Communication.event{
        channel = "tell",
        speaker = wc.speaker,
        receiver = wc.receiver,
        message = wc.message,
        line = line,
    }
end


function Communication.yell(trigger, line, wc)
    Communication.event{
        channel = "yell",
        speaker = wc.speaker,
        message = wc.message,
        line = line,
    }
end


function Communication.osay(trigger, line, wc)
    Communication.event{
        channel = "osay",
        speaker = wc.speaker,
        message = wc.message,
        line = line,
    }
end


function Communication.otell(trigger, line, wc)
    if not (wc.speaker == "You" or wc.receiver == "you") then
        -- Probably a smoted message, not an actual tell to player.
        return
    end

    Communication.event{
        channel = "otell",
        speaker = wc.speaker,
        receiver = wc.receiver,
        message = wc.message,
        line = line,
    }
end
]]>
</script>



<triggers>
    <trigger
     match="^(?<offender>.+) (?<method>approach(?:es)?|surprises?) (?<defender>.+) and prepares? to engage (?:you|him|her|it) in combat!$"
     enabled="y"
     script="Combat.engage"
     regexp="y"
     sequence="100"
    >
    </trigger>

    <trigger
     match="^(?<offender>.+) is DE(?:AD|STROYED)!$"
     enabled="y"
     script="Combat.death"
     regexp="y"
     sequence="100"
    >
    </trigger>
</triggers>


<script>
<![CDATA[
--------------------------------------------------
-- Combat
--------------------------------------------------


Combat = {}


function Combat.event(data)
    local path = "combat." .. data.action
    EventHandler.event(const.EVENT_TYPE.COMBAT, path, data)
end


function Combat.engage(trigger, line, wc)
    Combat.event{
        action = "engage",
        offender = wc.offender,
        defender = wc.defender,
        surprise = wc.method:match("^surprise") and true or false,
        line = line,
    }
end


function Combat.death(trigger, line, wc)
    Combat.event{
        action = "death",
        offender = "",
        defender = wc.defender,
        line = line,
    }
end
]]>
</script>


</muclient>
